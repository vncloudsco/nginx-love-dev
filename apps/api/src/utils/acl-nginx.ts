import prisma from '../config/database';
import logger from './logger';
import fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

const ACL_CONFIG_FILE = '/etc/nginx/conf.d/acl-rules.conf';
const NGINX_TEST_CMD = 'nginx -t';
const NGINX_RELOAD_CMD = 'systemctl reload nginx';

/**
 * Generate Nginx ACL configuration from database rules
 */
export async function generateAclConfig(): Promise<string> {
  try {
    // Get all enabled ACL rules
    const rules = await prisma.aclRule.findMany({
      where: {
        enabled: true
      },
      orderBy: [
        { type: 'desc' }, // Whitelists first
        { createdAt: 'asc' }
      ]
    });

    let config = `# ACL Rules - Auto-generated by Nginx Love UI
# Do not edit manually - Changes will be overwritten
# Generated at: ${new Date().toISOString()}
#
# This file is included in all domain vhost configurations
# Rules are processed in order: whitelist first, then blacklist
\n`;

    // Separate rules by field type
    const ipRules = rules.filter(r => r.conditionField === 'ip');
    const userAgentRules = rules.filter(r => r.conditionField === 'user_agent');
    const geoipRules = rules.filter(r => r.conditionField === 'geoip');
    const urlRules = rules.filter(r => r.conditionField === 'url');
    const methodRules = rules.filter(r => r.conditionField === 'method');
    const headerRules = rules.filter(r => r.conditionField === 'header');

    // Generate IP-based rules (most common)
    if (ipRules.length > 0) {
      config += `\n# ===== IP-Based Access Control =====\n\n`;
      
      const whitelists = ipRules.filter(r => r.type === 'whitelist');
      const blacklists = ipRules.filter(r => r.type === 'blacklist');

      // Whitelists first (allow)
      if (whitelists.length > 0) {
        config += `# IP Whitelists (Allow)\n`;
        for (const rule of whitelists) {
          config += `# ${rule.name}\n`;
          config += generateIpDirective(rule);
        }
      }

      // Blacklists (deny)
      if (blacklists.length > 0) {
        config += `\n# IP Blacklists (Deny)\n`;
        for (const rule of blacklists) {
          config += `# ${rule.name}\n`;
          config += generateIpDirective(rule);
        }
      }

      // Only add "deny all" if there are ONLY whitelists and NO blacklists
      // If there are blacklists, they should be specific denies without blocking everything else
      if (whitelists.length > 0 && blacklists.length === 0) {
        config += `\n# Deny all IPs not explicitly whitelisted\n`;
        config += `deny all;\n`;
      }
    }

    // Generate User-Agent rules
    if (userAgentRules.length > 0) {
      config += `\n# ===== User-Agent Based Access Control =====\n`;
      config += `\nif ($http_user_agent ~* "BLOCKED_AGENTS") {\n`;
      config += `    return 403 "Access Denied - Blocked User Agent";\n`;
      config += `}\n\n`;

      config += `# User-Agent Rules:\n`;
      for (const rule of userAgentRules) {
        if (rule.type === 'blacklist') {
          config += `# ${rule.name}\n`;
          config += `if ($http_user_agent ~* "${rule.conditionValue}") {\n`;
          if (rule.action === 'deny') {
            config += `    return 403 "Access Denied";\n`;
          } else if (rule.action === 'challenge') {
            config += `    # Challenge - implement CAPTCHA or rate limiting here\n`;
            config += `    return 429 "Too Many Requests - Please try again";\n`;
          }
          config += `}\n\n`;
        }
      }
    }

    // Generate URL-based rules
    if (urlRules.length > 0) {
      config += `\n# ===== URL-Based Access Control =====\n\n`;
      for (const rule of urlRules) {
        config += `# ${rule.name}\n`;
        const operator = rule.conditionOperator === 'regex' ? '~' : 
                        rule.conditionOperator === 'equals' ? '=' : '~*';
        config += `location ${operator} "${rule.conditionValue}" {\n`;
        if (rule.action === 'deny') {
          config += `    deny all;\n`;
        } else if (rule.action === 'allow') {
          config += `    allow all;\n`;
        }
        config += `}\n\n`;
      }
    }

    // Generate Method-based rules
    if (methodRules.length > 0) {
      config += `\n# ===== HTTP Method Access Control =====\n\n`;
      for (const rule of methodRules) {
        config += `# ${rule.name}\n`;
        if (rule.type === 'blacklist' && rule.action === 'deny') {
          config += `if ($request_method = "${rule.conditionValue}") {\n`;
          config += `    return 405 "Method Not Allowed";\n`;
          config += `}\n\n`;
        }
      }
    }

    config += `\n# End of ACL Rules\n`;

    return config;
  } catch (error) {
    logger.error('Failed to generate ACL config:', error);
    throw error;
  }
}

/**
 * Generate IP directive based on rule
 */
function generateIpDirective(rule: any): string {
  let directive = '';
  
  const action = rule.type === 'whitelist' ? 'allow' : 'deny';
  
  if (rule.conditionOperator === 'equals') {
    // Exact IP match
    directive = `${action} ${rule.conditionValue};\n`;
  } else if (rule.conditionOperator === 'regex') {
    // Regex pattern - use geo module or map
    directive = `# Regex pattern: ${rule.conditionValue}\n`;
    directive += `# Note: Nginx IP matching doesn't support regex directly\n`;
    directive += `# Consider using CIDR notation or specific IPs\n`;
  } else if (rule.conditionOperator === 'contains') {
    // Network/CIDR
    directive = `${action} ${rule.conditionValue};\n`;
  }
  
  return directive;
}

/**
 * Write ACL config to Nginx configuration file
 */
export async function writeAclConfig(config: string): Promise<void> {
  try {
    await fs.writeFile(ACL_CONFIG_FILE, config, 'utf8');
    logger.info(`ACL config written to ${ACL_CONFIG_FILE}`);
  } catch (error) {
    logger.error('Failed to write ACL config:', error);
    throw error;
  }
}

/**
 * Test Nginx configuration
 */
export async function testNginxConfig(): Promise<boolean> {
  try {
    const { stdout, stderr } = await execAsync(NGINX_TEST_CMD);
    logger.info('Nginx config test passed:', stdout);
    return true;
  } catch (error: any) {
    logger.error('Nginx config test failed:', error.stderr || error.message);
    return false;
  }
}

/**
 * Reload Nginx to apply new configuration
 */
export async function reloadNginx(): Promise<void> {
  try {
    const { stdout } = await execAsync(NGINX_RELOAD_CMD);
    logger.info('Nginx reloaded successfully:', stdout);
  } catch (error: any) {
    logger.error('Failed to reload Nginx:', error);
    throw error;
  }
}

/**
 * Apply ACL rules to Nginx
 * Main function to generate config, test, and reload
 */
export async function applyAclRules(): Promise<{ success: boolean; message: string }> {
  try {
    logger.info('üîÑ Starting ACL rules application...');

    // 1. Generate config from database
    logger.info('üìù Generating ACL configuration...');
    const config = await generateAclConfig();

    // 2. Write to file
    logger.info('üíæ Writing ACL config to Nginx...');
    await writeAclConfig(config);

    // 3. Test Nginx config
    logger.info('üß™ Testing Nginx configuration...');
    const testPassed = await testNginxConfig();
    
    if (!testPassed) {
      return {
        success: false,
        message: 'Nginx configuration test failed. Rules not applied.'
      };
    }

    // 4. Reload Nginx
    logger.info('üîÉ Reloading Nginx...');
    await reloadNginx();

    logger.info('‚úÖ ACL rules applied successfully');
    
    return {
      success: true,
      message: 'ACL rules applied successfully'
    };
  } catch (error: any) {
    logger.error('‚ùå Failed to apply ACL rules:', error);
    return {
      success: false,
      message: `Failed to apply ACL rules: ${error.message}`
    };
  }
}

/**
 * Initialize ACL config file if not exists
 */
export async function initializeAclConfig(): Promise<void> {
  try {
    try {
      await fs.access(ACL_CONFIG_FILE);
      logger.info('ACL config file already exists');
    } catch {
      // File doesn't exist, create it
      const emptyConfig = `# ACL Rules - Nginx Love UI
# This file will be populated with ACL rules
\n# No rules configured yet\n`;
      
      await writeAclConfig(emptyConfig);
      logger.info('ACL config file initialized');
    }
  } catch (error) {
    logger.error('Failed to initialize ACL config:', error);
  }
}
